# মডেল

খুব সহজ ভাবে বলতে গেলে, আমাদের এই ম্যাথেম্যাটিক্যাল মডেলটি প্লেস হোল্ডার ভ্যারিয়েবল x এর মধ্যে থাকা ইমেজ গুলোর সাথে weights গুন করে এবং শেষে bias যোগ করে। আর এর রেজাল্টটি হয় একটি ম্যাট্রিক্স যার সেইপ হবে, \[num\_images, num\_classes\]. কারন কি? কারন হচ্ছে, ইনপুট লেয়ারের ডাটা ম্যাট্রিক্স বা x এর সেইপ হচ্ছে \[num\_images, img\_size\_flat\] \(None এর জায়গায় যেকোনো সংখ্যক ইমেজ দেয়া যাবে, মনে আছে? ধরলাম num\_images সংখ্যক দিয়েছি\), আর weights এর সেইপ হচ্ছে \[img\_size\_flat, num\_classes\]. XxY আর YxZ গুন করলে XxZ -ই হয় :\) তাই রেজাল্ট ম্যাট্রিক্সের সেইপ হবে, \[num\_images, num\_classes\]. আর এই ম্যাট্রিক্সের প্রত্যেকটি row এর সাথে bias ভেক্টর যোগ হয়। অর্থাৎ যদি ম্যাট্রিক্সে শুধু দুটো ইমেজের ডাটা থাকে সেগুলো হবে এরকম - \[\[c00, c01, c02, c03, c04, c05, c06, c07, c08, c09\],\[c10, c11, c12, c13, c14, c15, c16, c17, c18, c19\]\]. আর এগুলোর সাথে bias \(দেখতে এমন - \[b0, b1, b2, b3, b4, b5, b6, b7, b8, b9\]\) ভেক্টর যোগ করা যাবে খুব সহজে নিচের স্টেটমেন্ট দিয়ে।

```python
# Cell 15
logits = tf.matmul(x, weights) + biases
```

জেনে রাখা ভালো - logits নামটি TensorFlow নিয়ে কাজ করার সময় একটা কনভেনশনাল নাম মাত্র। তো, logits হচ্ছে একটা ম্যাট্রিক্স যার row সংখ্যা = num\_images এবং কলাম সংখ্যা = num\_classes। আর তাই এভাবে বলা যায় - i তম row \(ইমেজ\) এর সাথে j তম কলাম \(ক্লাস\) -এর সম্পর্ক দেখেই ওই ইমেজের ক্লাস নির্ধারণ সম্ভব।

তবে সমস্যা হচ্ছে এখানে একটি row এর কলাম ভিত্তিক ভ্যালু গুলোর মান নানা রকম অর্থাৎ ছোট বড় মিলিয়ে। তাই কলামের ভ্যালু গুলো এই অবস্থায় সরাসরি দেখে ক্লাস বলা একটু টাফ। তাই আমরা যেটা করতে পারি, logits ম্যাট্রিক্সের প্রত্যেকটা row এর ভ্যালুগুলোকে নরমালাইজ করতে পারি যাতে করে পুরো একটা row এর ১০টি ভ্যালুর সমষ্টি ১ হয়। এবং প্রত্যেকটি ভ্যালু ০ থেকে ১ এর মধ্যে হয়। তাহলে এটাকে আমরা একটা প্রোব্যাবিলিটি ডিস্ট্রিউবিউশন বলতে পারি। যাই হোক, এই কাজটা করার জন্য আমরা softmax মেথডের সাহায্য নেবো নিচের মত,

```python
# Cell 16
y_pred = tf.nn.softmax(logits)
```

তার মানে এবার প্রত্যেকটা row \(প্রত্যেকটা ইমেজ\) এর ১০ টা করে ভ্যালু \(ক্লাস\) হবে ০ থেকে ১ এর মধ্যে এবং যেটার ভ্যালু বেশি হবে অর্থাৎ প্রোব্যাব্লিলিটি সবচেয়ে বেশি হবে ধরা যায় ওই row \(ইমেজ\) এর ক্লাস/লেবেল ওইটা। ওইটা বলতে ১০টা কলামের ওই নাম্বার কলাম। তো, যে কলামের ভ্যালু বেশি সেই কলামের ইনডেক্স পেতে আমরা আগেও একবার ব্যবহার করেছি argmax মেথড। তাহলে আবার আমরা y\_pred এর উপর এই মেথডের ইমপ্লিমেন্টেশন করে ফেলি।

```python
# Cell 17
y_pred_cls = tf.argmax(y_pred, dimension=1)
```

এখন পর্যন্ত আমরা কি করলাম? ইনপুট ইমেজ নেয়ার ব্যবস্থা করেছি। সেই ইনপুট ইমেজগুলোর ট্রু ক্লাস ইনপুটের ব্যবস্থা করেছি। ইনপুট লেয়ার আর আউটপুট লেয়ার এর কাঠামো ঠিক করেছি। ইনপুট লেয়ার থেকে শূন্য ওয়েট গুন করে তারপর বায়াস যোগ করে আউটপুট লেয়ারে logits ম্যাট্রিক্স পেয়েছি এবং এটার উপর softmax, argmax আপ্লাই করে প্রত্যেকটি ইমেজের জন্য একটি করে ক্যালকুলেটেড ক্লাস পেয়েছি। অর্থাৎ ইনপুট নিয়ে মডেলের হিসাব করা রেজাল্ট পাওয়ার ব্যবস্থা হয়েছে। এরপর দেখতে হবে এই রেজাল্ট সঠিক ক্লাস থেকে কেমন ফারাকে আছে। তার উপর ভিত্তি করেই ওয়েট, বায়াস গুলো অ্যাডজাস্ট করবো।

